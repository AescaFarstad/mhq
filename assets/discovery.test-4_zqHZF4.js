const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-DZQyav9u.js","assets/index-muWhf4p0.css"])))=>i.map(i=>d[i]);
import{T as r,_ as m}from"./index-DZQyav9u.js";let l,a;const D=typeof window>"u";if(D)l=require("../src/logic/GameState").GameState,a=require("../src/utils/stringUtils").obfuscateString;else{const e=await m(()=>import("./index-DZQyav9u.js").then(t=>t.G),__vite__mapDeps([0,1])),s=await m(()=>import("./index-DZQyav9u.js").then(t=>t.s),__vite__mapDeps([0,1]));l=e.GameState,a=s.obfuscateString}function u(){try{return new l}catch{return{discoveredItems:new Set,isDiscovered:function(s){return this.discoveredItems.has(s)},markAsDiscovered:function(s){this.discoveredItems.add(s)}}}}function y(){const e=u(),s="test-item-123",t=r.false(e.isDiscovered(s),"Item should not be discovered initially");if(!t.success)return t;e.discoveredItems.add(s);const i=r.true(e.isDiscovered(s),"Item should be discovered after being added");return i.success?{success:!0}:i}function b(){const e=u(),s=["item1","item2","item3","item4"];e.discoveredItems.add(s[0]),e.discoveredItems.add(s[1]);const t=r.equals(e.discoveredItems.size,2,"Discovery set should have correct size");if(!t.success)return t;const i=r.true(e.isDiscovered(s[0]),"First item should be discovered");if(!i.success)return i;const o=r.false(e.isDiscovered(s[2]),"Third item should not be discovered");if(!o.success)return o;e.discoveredItems.add(s[0]);const c=r.equals(e.discoveredItems.size,2,"Adding duplicate should not increase size");return c.success?{success:!0}:c}function g(){const e=u(),s=r.false(e.isDiscovered(""),"Empty string should not be discovered");if(!s.success)return s;e.discoveredItems.add("");const t=r.true(e.isDiscovered(""),"Empty string should be discoverable");if(!t.success)return t;try{const i=e.isDiscovered(void 0),o=r.false(i,"Undefined should not be discovered");if(!o.success)return o}catch{}return{success:!0}}function p(){const e=u(),s="Secret Knowledge",t="secret-knowledge",i=a(s,1,0),o=r.notEquals(i,s,"Text should be obfuscated when not discovered");if(!o.success)return o;function c(f,h){return e.isDiscovered(h)?f:a(f,1,0)}const n=c(s,t),d=r.notEquals(n,s,"Display text should be obfuscated before discovery");if(!d.success)return d;e.discoveredItems.add(t);const I=c(s,t),v=r.equals(I,s,"Display text should be clear after discovery");return v.success?{success:!0}:v}function S(){const e=u(),s=["skill1","building1","attribute1"];s.forEach(o=>e.discoveredItems.add(o));for(const o of s){const c=r.true(e.isDiscovered(o),`Item ${o} should be discovered`);if(!c.success)return c}e.discoveredItems.delete(s[1]);const t=r.true(e.isDiscovered(s[0]),"Other items should still be discovered");if(!t.success)return t;const i=r.false(e.isDiscovered(s[1]),"Removed item should no longer be discovered");return i.success?{success:!0}:i}function T(){const e=u(),s="a".repeat(1e3);e.discoveredItems.add(s);const t=r.true(e.isDiscovered(s),"Very long item ID should work");if(!t.success)return t;const i="!@#$%^&*()_+-=[]{}|;:,.<>?";e.discoveredItems.add(i);const o=r.true(e.isDiscovered(i),"Special character item ID should work");if(!o.success)return o;const c="ðŸŽ®ðŸŽ¯ðŸŽªðŸŽ¨ðŸŽ­ðŸŽª";e.discoveredItems.add(c);const n=r.true(e.isDiscovered(c),"Unicode item ID should work");return n.success?{success:!0}:n}function _(){const e=u(),s=1e3,t=Array.from({length:s},(n,d)=>`item_${d}`);t.forEach(n=>e.discoveredItems.add(n));const i=r.equals(e.discoveredItems.size,s,`Should have ${s} discovered items`);if(!i.success)return i;const o=[0,100,250,500,750,999];for(const n of o){const d=r.true(e.isDiscovered(t[n]),`Sample item at index ${n} should be discovered`);if(!d.success)return d}e.discoveredItems.clear();const c=r.equals(e.discoveredItems.size,0,"All items should be cleared");return c.success?{success:!0}:c}function w(){return{name:"Discovery System Tests",tests:[{name:"Basic Discovery Functionality",run:y},{name:"Discovery Set Operations",run:b},{name:"Empty and Invalid IDs",run:g},{name:"Integration with Obfuscation",run:p},{name:"Discovery State Persistence",run:S},{name:"Boundary Conditions",run:T},{name:"Bulk Operations",run:_}]}}D&&typeof require<"u"&&require.main===module&&m(async()=>{const{runTestSuite:e}=await import("./index-DZQyav9u.js").then(s=>s.t);return{runTestSuite:e}},__vite__mapDeps([0,1])).then(({runTestSuite:e})=>{e(w()).then(s=>{const t=s.failedTests>0?1:0;process.exit(t)})});export{w as createDiscoveryTests};
